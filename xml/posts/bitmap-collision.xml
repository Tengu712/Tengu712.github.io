<?xml version="1.0" encoding="utf-8" ?>
<blob>

  <title>ビットマップによる衝突判定</title>
  <date>2023/10/26</date>
  <tags>
    <tag>experiment</tag>
  </tags>

  <main>
    <h2>概要</h2>

    <div class="ta-center">
      <img src="https://img.skdassoc.work/posts/bitmap-collision/01.gif" alt="simulation" width="50%" />
      <br />
      <label class="m-0 fs-0_8rem">図1 矩形の判定でのシミュレーション</label>
    </div>

    <p>
      当記事は、<b>2D弾幕STGにおける衝突判定</b>をビットマップ化することで高速化できるか、という実験の報告である。
    </p>

    <p>
      2D弾幕STGに限らず2Dゲーム全般において、余程凝らない限り、レンダリングは16ms以内に完遂される。
      一方で、物体の演算は、それが複雑であったり・総数が多かったりすると、16msに収まらない場合がある。
      こと衝突判定については、愚直に実装すると<InlineMath>O(N^2)</InlineMath>となるため、物体の数が増えるほどコストが無視できない計算となる。
    </p>

    <p>
      しかし、単純な2D弾幕STGは「敵や敵の弾」と「自機や自機の弾」の二種類しか当たり判定を持たない。
      この性質を利用して、ビットマップを用いた実質<InlineMath>O(N)</InlineMath>での衝突判定の性能を検証する。
    </p>

    <div class="ta-center">
      <a href="https://github.com/Tengu712/Bitmap-Collision-Experiment">ソースコードはこちら</a>
    </div>

    <h2>ビットマップ方式</h2>

    <p>
      「何かと衝突した」という程度の衝突判定は、自分の当たり判定の座標に「何か」がないかを確認すればいい。
      つまり、座標をkeyに「何かがあること」というvalueを得られればいい。
      これに適したデータ構造は、ビットマップであろう。
    </p>

    <p>
      衝突判定をビットマップを用いて行うのは、タイルベースゲームにおいては珍しいことではない。
      ビットマップのサイズが小さく、「何かがあるか否か」という単純な真理値を持つだけでいいからである。
    </p>

    <p>
      しかし、2D弾幕STGのような連続的な座標を取る物体の衝突判定においては、タイルベースゲーム程簡単ではない。
      一ピクセルに、二次元的な当たり判定の情報を詰めなければならないからである。
      愚直な実装は、ビットを内部ピクセルとする方法であろう。
      しかし、後述するが、これはそれだけ多くのサンプリングを行うことに他ならず、計算量が増えてしまう。
    </p>

    <p>
      ここで、一旦、<b>低精度で衝突判定を行う</b>ことにして、一ピクセルにおける物体の占有率(coverage)を考える。
    </p>

    <p>
      原理的には次の図の通りである。
      自分の当たり判定がある座標のピクセルを参照し、自分の当たり判定のcoverageと相手のビットマップ上のcoverageの合計が閾値を超えているか否かで判定する。
    </p>

    <div class="ta-center">
      <img src="https://img.skdassoc.work/posts/bitmap-collision/02.png" alt="bitmap coverage" width="85%" />
      <br />
      <label class="m-0 fs-0_8rem">図2 coverageを用いる衝突判定の原理</label>
    </div>

    <h2>円の判定</h2>

    <p>
      円は、中心からの距離が一定である図形である。
      こと2D弾幕STGの衝突判定においては、一般的な弾の当たり判定は円であるべきである。
      （東方紅魔郷がすべての当たり判定に矩形を用いているのは、東方界隈では有名）
    </p>

    <p>
      円での衝突判定を行うアルゴリズムは以下のようになる。
    </p>

    <ol>
      <li>
        グループ1のすべての物体について、
        <ol>
          <li>物体の座標を更新</li>
          <li>グループ1のビットマップに物体のcoverageを記録</li>
          <li>物体のビットマップに物体のcoverageを記録</li>
        </ol>
      </li>
      <li>
        グループ2のすべての物体について、
        <ol>
          <li>物体の座標を更新</li>
          <li>グループ2のビットマップに物体のcoverageを記録</li>
          <li>物体のビットマップに物体のcoverageを記録</li>
        </ol>
      </li>
      <li>グループ1のすべての物体について、物体のビットマップとグループ2のビットマップから衝突判定</li>
      <li>グループ2のすべての物体について、物体のビットマップとグループ1のビットマップから衝突判定</li>
    </ol>

    <p>
      coverageの記録に三点の難点がある。
    </p>

    <p>
      まず、物体が存在しうるピクセルのみを更新すればいいが、これを判定するのは難しい。
      従って、
      左を<InlineMath>\lfloor x-r \rfloor</InlineMath>、
      右を<InlineMath>\lceil x+r \rceil</InlineMath>、
      下を<InlineMath>\lfloor y-r \rfloor</InlineMath>、
      上を<InlineMath>\lceil y+r \rceil</InlineMath>
      とする矩形領域内を更新領域とし、
      ピクセルの中点が
      <InlineMath>r+\sqrt{2}</InlineMath>より遠ければcontinue、
      <InlineMath>r-\sqrt{2}</InlineMath>より近ければ最大値とし、
      それ以外は境界上とみなしてサンプリングを行う。
    </p>

    <p>
      また、正方形と円が与えられたとき、共通面積を算出するのは数学的に難しい。
      つまり、coverageを数学的計算によって算出することはできない。
      従って、ピクセルを幾つかに分割してサンプリングを行い、その結果を総合してcoverageを概算する。
    </p>

    <p>
      そして、グループごとのビットマップだけを比較しても、正しい衝突判定はできない。
      なぜなら、ある物体が与えられたとき「coverageが0より大きい→ある物体が重なっている」は真ではないからである。
      従って、物体ごとにビットマップを持つ必要がある。
    </p>

    <p>
      以上を考慮すると、計算量は<InlineMath>O(NSR^2)</InlineMath>であると考えられる。
      ただし、物体数を<InlineMath>N</InlineMath>、物体の半径を<InlineMath>R</InlineMath>、サンプル数を<InlineMath>S</InlineMath>とする。
      <InlineMath>SR^2</InlineMath>が<InlineMath>N</InlineMath>に対して十分小さいとき、計算量は<InlineMath>O(N)</InlineMath>に見積もられる。
    </p>

    <h2>矩形の判定</h2>

    <p>
      前章の判定は、<InlineMath>SR^2</InlineMath>の計算量が地味に無視できないのに加え、ビットマップにアクセスするためのオーバーヘッドのためにか、実はそれほど速度が出ない。
      どれほど速度が出ないかというと、<InlineMath>N=1000</InlineMath>の衝突判定でようやく愚直実装に追いつく程である。
    </p>

    <p>
      そこで、<b>conservativityを完全に無視して当たり判定を矩形にする</b>ことによって、サンプリングおよび物体ごとのビットマップを消すことにする。
    </p>

    <p>
      矩形による判定では境界のcoverageを求めるのが容易である。次のように求める。
    </p>

    <ul>
      <li>左辺：<InlineMath>1-(left-\lfloor left \rfloor)</InlineMath></li>
      <li>右辺：<InlineMath>right-\lfloor right \rfloor</InlineMath></li>
      <li>下辺：<InlineMath>1-(bottom-\lfloor bottom \rfloor)</InlineMath></li>
      <li>上辺：<InlineMath>top-\lfloor top \rfloor</InlineMath></li>
    </ul>

    <p>
      領域の頂点および各辺のcoverageを保存しておけば、coverageが0より大きいピクセルについて、自物体における外か内か境界上かでcoverageを場合分ければいいだけである。
    </p>

    <p>
      計算量は<InlineMath>O(NR^2)</InlineMath>となる。
      こちらも同様に、<InlineMath>R^2</InlineMath>が<InlineMath>N</InlineMath>に対して十分小さいとき、<InlineMath>O(N)</InlineMath>に見積もられる。
      ただし、円の実装が各ピクセルに対して条件分岐していたのに対し、矩形の実装では走査の開始と終了のみ条件分岐を行うため、実際の計算量は円の実装より少なくなる。
    </p>

    <h2>結果</h2>

    <p>
      <InlineMath>N=100, 500, 1000, 2000, 3000, 4000, 5000</InlineMath>とし、それぞれ1000フレーム間物理演算を行った。
      結果を線形補完したグラフを次に示す。
    </p>

    <div class="ta-center">
      <img src="https://img.skdassoc.work/posts/bitmap-collision/03.png" alt="result all" width="70%" />
      <br />
      <label class="m-0 fs-0_8rem">図3 結果(全体)</label>
    </div>

    <p>
      確かにビットマップ方式では<InlineMath>O(N)</InlineMath>となっていることがわかる。
      しかし、これでは差が開きすぎていて、交差点が見えづらい。
      従って、X軸の範囲を0から2000、Y軸の範囲を0から2までトリミングしたグラフを次に示す。
    </p>

    <div class="ta-center">
      <img src="https://img.skdassoc.work/posts/bitmap-collision/04.png" alt="result part" width="70%" />
      <br />
      <label class="m-0 fs-0_8rem">図4 結果(部分)</label>
    </div>

    <p>
      円の判定は<InlineMath>N=1000</InlineMath>で追いつき、矩形の判定では<InlineMath>N=200</InlineMath>付近で追いついていることがわかる。
    </p>

    <h2>結果を受けて</h2>

    <p>
      ビットマップ方式を使いましょう。……とはならない。
      特に、矩形の判定は、conservativityを完全に無視しているため、プレイ体験を大きく損なう可能性がある。
    </p>

    <p>
      前章のグラフは、1000フレーム間演算を行っていることを考慮すると、単位を秒からミリ秒へ読み換えれば、1フレームにかかる時間がわかる。
      つまり、<InlineMath>N=1000</InlineMath>のとき、愚直実装と円の実装は1ミリ秒である。
      <b>ぶっちゃけ1ミリ秒なんて誤差なので、衝突判定の最適化をする理由は、実はないのかもしれない</b>。
    </p>

    <p>
      このことを踏まえて、どの方式を使うべきか、以下のように考えた。
    </p>

    <ul>
      <li>正確な衝突判定を行いたい→愚直</li>
      <li>物体の数が少ない→愚直</li>
      <li><InlineMath>N&gt;2000</InlineMath>となるような衝突判定を行いたい→円</li>
      <li>とにかく高速に衝突判定をしたい→矩形</li>
      <li>そもそも矩形で衝突判定をする→矩形</li>
    </ul>

    <p>
      ところで、このビットマップ方式における当たり判定の書込みは、レンダリング処理に他ならないため、GPUで行うことで高速化する方法が考えられる。
      興味が湧いたら、実装するかもしれない。
    </p>
  </main>
</blob>

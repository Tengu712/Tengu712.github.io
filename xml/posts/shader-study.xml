<?xml version="1.0" encoding="utf-8" ?>
<blob>
  <title>シェーダの基礎を学習した</title>
  <date>2023/12/15</date>
  <tags><tag>cg</tag></tags>
  
  <main>
    <h2>概要</h2>

    <p>
      2Dゲーム作成のためにしかグラフィックスAPIを使っていなかった都合上、3Dシェーディングの知識を欠いていた。
    </p>

    <p>
      最近、諸事情あってPhong反射モデルを実装することになった。
      そこで多くの曖昧な知識・知らない知識・勘違いしていた知識が発覚したため、学習した。
    </p>

    <p>
      学習した内容を当記事にまとめる。
      尚、グラフィックスAPIの仕様についてはOpenGL系のみを対象とする。
    </p>

    <div class="ta-center">
      <a href="https://github.com/Tengu712/Sample-Phong-Reflection">ソースコードはこちら</a>
    </div>


    <h2>逆行列の取得</h2>

    <p>
      行列<InlineMath>A</InlineMath>の逆行列をGauss-Jordan法(掃き出し法)で計算するアルゴリズムは次のようである。
    </p>

    <ol>
      <li><InlineMath>A</InlineMath>と同じサイズの単位行列<InlineMath>E</InlineMath>を作る</li>
      <li>
        すべての<InlineMath>i</InlineMath>行目について次を繰り返す
        <ol>
          <li>
            <InlineMath>A, E</InlineMath>の<InlineMath>i</InlineMath>行目のすべて要素を<InlineMath>A_{ii}</InlineMath>で割る (<InlineMath>A_{ii}</InlineMath>が1になる)
          </li>
          <li>
            すべての<InlineMath>i'(\neq i)</InlineMath>行目について次を繰り返す
            <ol>
              <li>
                <InlineMath>A</InlineMath>の<InlineMath>i'</InlineMath>行目から<InlineMath>i</InlineMath>行目の<InlineMath>A_{i'i}</InlineMath>倍を引く (<InlineMath>A_{i'i}</InlineMath>が0になる)
              </li>
              <li><InlineMath>E</InlineMath>の<InlineMath>i'</InlineMath>行目から<InlineMath>i</InlineMath>行目の<InlineMath>E_{i'i}</InlineMath>倍を引く</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>

    <p>
      上の実装では、対角成分<InlineMath>A_{ii}</InlineMath>に0があると正確に計算を終えられない。
      これを解決するために部分ピボット選択を行う。
      これは<InlineMath>i</InlineMath>行目以降のすべて行の<InlineMath>i</InlineMath>列目の要素で最も大きな要素を見つけ、それが<InlineMath>A_{ii}</InlineMath>となるように行をスワップする行為である。
      スワップ時に<InlineMath>E</InlineMath>も連動してスワップすることに注意する。
    </p>

    <p>
      恐らく、どのようなアルゴリズムでも、逆行列を求める計算量は<InlineMath>O(N^3)</InlineMath>と重い。
      できれば逆行列を求める状況は作らない方が良いだろう。
    </p>


    <h2>行列の列優先</h2>

    <p>
      OpenGL系では、列ベクトルを用いる。
      従って、例えば平行移動は以下のように計算される。
    </p>

    <BlockMath>
      \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; t_x\\
        0 &amp; 1 &amp; 0 &amp; t_y\\
        0 &amp; 0 &amp; 1 &amp; t_z\\
        0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}
      \begin{pmatrix}
        x\\
        y\\
        z\\
        1
      \end{pmatrix}
      =
      \begin{pmatrix}
        x + t_x\\
        y + t_y\\
        z + t_z\\
        1
      \end{pmatrix}
    </BlockMath>

    <p>
      しかし、OpenGL系では、行列は列優先でレイアウトされる。
      GLSLのmat4はvec4[4]を意味し、vec4は前述の通り列ベクトルである。
      つまり、行列の各要素にデータレイアウト上のインデックスを振ると次のようになる。
    </p>

    <BlockMath>
      \begin{pmatrix}
        1 &amp; &amp; 5 &amp; &amp; 9 &amp; &amp; 13\\
        2 &amp; &amp; 6 &amp; &amp; 10 &amp; &amp; 14\\
        3 &amp; &amp; 7 &amp; &amp; 11 &amp; &amp; 15\\
        4 &amp; &amp; 8 &amp; &amp; 12 &amp; &amp; 16
      \end{pmatrix}
    </BlockMath>
    
    <p>
      シェーダ転送時の転置がサポートされていない限りは、プログラム側も列優先でデータを作らなければならない。
      要は、常に数学的な行列を転置した行列を使うことになるため、演算の実装を誤ると期待した結果が得られなくなる。
      これを回避するために、数学的な行列のまま操作できる機構を作るべきだろう。
      サンプルコードのmath.jsがそれである。
    </p>

    <p>
      ただ、なぜ列優先なのかわからなかった。
      行列の乗算について、もし行ベクトルを用いるのであれば複数回の内積計算になるが、列ベクトルを用いると飛び飛びの要素を掛け合わせなければならない。
      つまり、キャッシュ効率が悪そうに見える。
      所詮32x16bit程度のデータを飛び飛びに選んでレジスタへ入れるオーバヘッドは、考慮すべきほど大きくないということなのだろうか。
    </p>


    <h2>ビュー行列の作成</h2>

    <p>
      ビュー行列は、カメラから見た座標系に物体を移すための変換行列である。
      深くは考えていないが、恐らく、カメラには二種類の設定方式があり、それぞれに強いビュー行列作成手段がある。
    </p>

    <p>
      まず簡単なのは、カメラの座標と回転角を設定する方式である。
      物体を、カメラの座標だけ「逆に」平行移動し、カメラの回転角だけ「逆に」回転させれば良い。
      従って、カメラの座標・回転角を<InlineMath>C_{trs}, C_{rot}</InlineMath>として、ビュー行列<InlineMath>V</InlineMath>は次のようになる。
      最右辺の各逆行列は、パラメータを-1倍した各種変換行列でしかないので、逆行列を求める必要はない。
    </p>

    <BlockMath>
      V = (C_{trs}C_{rot})^{-1}=C_{rot}^{-1}C_{trs}^{-1}
    </BlockMath>

    <p>
      もう一つは、カメラの座標・注視点・上方向を設定する方式である。
      ビュー座標系の座標軸を求め、それに従って物体を移動する必要がある。
      まず、座標軸を求める。
      カメラの座標・注視点・上方向を<InlineMath>v_{trs}, v_{lookat}, v_{up}</InlineMath>として、それぞれの座標軸<InlineMath>X, Y, Z</InlineMath>は次のようになる。
      外積の結果が右ねじの法則に従うことに留意する。
    </p>

    <BlockMath>
      Z = v_{lookat} - v_{trs}\\
      X = Z \times v_{up}\\
      Y = X \times Z
    </BlockMath>

    <p>
      次に、座標軸とカメラ座標をもとにビュー行列を作る。
    </p>

    <BlockMath>
      \begin{pmatrix}
        X_x &amp; X_y &amp; X_z &amp; -(v_{trs} \cdot X)\\
        Y_x &amp; Y_y &amp; Y_z &amp; -(v_{trs} \cdot Y)\\
        Z_x &amp; Z_y &amp; Z_z &amp; -(v_{trs} \cdot Z)\\
        0 &amp; 0 &amp; 0 &amp; 1
      \end{pmatrix}
    </BlockMath>

    <p>
      サンプルでは後者の方式を採用した。
    </p>


    <h2>法線ベクトルの変換</h2>

    <p>
      ライティングのためには、法線ベクトルを適切に回転・拡縮しなければならない。
      この回転は、物体に対するそれと同一である。
      一方拡縮は、各パラメータが逆数となる。
      従って、ワールド変換行列とは別に、そのような回転行列・拡縮行列をシェーダへ転送し、法線ベクトルに掛け合わせて・正規化すれば良い。
    </p>

    <p>
      このような行列をワールド変換行列から作成できるらしい。
      法線ベクトルを適切に変換するための行列<InlineMath>W_{normal}</InlineMath>は、ワールド変換行列を<InlineMath>W</InlineMath>として、次のように求める。
    </p>

    <BlockMath>
      W_{normal} = (W^{-1})^\mathrm{T}
    </BlockMath>


    <h2>Phong反射モデル</h2>

    <p>
      Phong反射モデルは、簡単で軽量なシェーディングモデルである。
      環境光、拡散光、鏡面光の三要素をライトとマテリアルが持ち、その相互作用によって一表面の色(輝度)を決定する。
      Direct3D 9やOpenGL 2.1までは標準実装されていたらしい。
      モデル及び各変数の説明は次のようである。
    </p>

    <BlockMath>
      I_p = k_ai_a + k_d (L \cdot N) i_d + k_s (R \cdot V)^\alpha i_s
    </BlockMath>

    <ul>
      <li><InlineMath>I_p</InlineMath>: 表面の色</li>
      <li><InlineMath>k_a</InlineMath>: 物質の環境反射係数</li>
      <li><InlineMath>k_d</InlineMath>: 物質の拡散反射係数</li>
      <li><InlineMath>k_s</InlineMath>: 物質の鏡面反射係数</li>
      <li><InlineMath>i_a</InlineMath>: 環境光色</li>
      <li><InlineMath>i_d</InlineMath>: 拡散光色</li>
      <li><InlineMath>i_s</InlineMath>: 鏡面光色</li>
      <li><InlineMath>\alpha</InlineMath>: 物質の光沢度 (大きいほど反射光が小さく・強くなる)</li>
      <li><InlineMath>L</InlineMath>: 表面からライトへの方向ベクトル</li>
      <li><InlineMath>N</InlineMath>: 表面の法線ベクトル</li>
      <li><InlineMath>R</InlineMath>: 反射光の方向ベクトル</li>
      <li><InlineMath>V</InlineMath>: 表面からカメラへの方向ベクトル</li>
    </ul>

    <p>
      ただし、<InlineMath>R</InlineMath>は次のように求められる。
      尚、GLSLにはreflect関数という同じ計算をする関数がある。
      が、サンプルではそのことを知らなかったため利用していない。
    </p>

    <BlockMath>
      R = -V + 2 (V \cdot N) N
    </BlockMath>

    <p>
      また、各種反射係数はスカラーでもベクトルでもよい。
      ベクトルである場合は、ベクトル同士の乗算が以下のような計算となることに注意する。
      尚、反射係数がベクトルであるとは、各種光色の各要素に対する係数がベクトルを成すことを意味する。
    </p>

    <BlockMath>
      uv \overset{\mathrm{def}}{\Leftrightarrow} uv^\mathrm{T}
    </BlockMath>      

    <h2>参考文献</h2>

    <ul>
        <li><a href="https://yttm-work.jp/gmpg/gmpg_0003.html">YTTM-WORK, ビュー座標変換</a></li>
        <li><a href="http://marupeke296.com/DXG_No72_ViewProjInfo.html">○×つくろ～どっとコム, その72 ビュー・射影変換行列が持つ情報を抜き出そう</a></li>
        <li><a href="https://raytracing.hatenablog.com/entry/20130325/1364229762">穴日記, 法線の変換の話</a></li>
    </ul>
  </main>
</blob>
<h2>背景</h2>

<p>
    ゲーム制作向けフロントエンドフレームワークのAPIをどうしようかと考えたところ、どっちかを動的リンクライブラリにするのが良いだろうという結論に至った。
</p>

<p>
    動的リンクには、暗黙的なリンクと動的的なリンクの二つの手法がある。
    事前に用いるライブラリ名（とその検索パス）を指定しておく方法と、dlsym関数やGetProcAddress関数を用いて動的に関数を取得する方法とである。
</p>

<p>
    なんとなく、関数を余計に呼び出す分、速度が落ちるのではないかと思い、速度比較実験を行ってみた。
</p>

<h2>Linux</h2>

<p>
    今回用いたソースファイルは以下。
</p>

<ul>
    <li>sosrcgen.rs：共有ライブラリのソースコード生成器</li>
    <li>imsrcgen.rs：暗黙的リンク用のソースコード生成器</li>
    <li>exsrcgen.rs：動的リンク用のソースコード生成器</li>
    <li>Makefile：ビルド用</li>
</ul>

<p>
    コードは順に以下のよう。簡単に言えば、100000個の外部関数を動的にリンクするプログラムである。
</p>

<pre class="codeblock rust">// sosrcgen.rs
use std::io::Write;
fn main() {
    let mut out = std::io::BufWriter::new(std::io::stdout().lock());
    for i in 0..100000 {
        write!(out, "int f{0}() {{ return {0}; }} ", i).unwrap();
    }
}</pre>

<pre class="codeblock rust">// imsrcgen.rs
use std::io::Write;
const MAIN1: &'static str = "
#include &lt;stdio.h&gt;
int main() {
    int sum = 0;
";
const MAIN2: &'static str = "
    printf(\"sum = %d\\n\", sum);
    return 0;
}
";
fn main() {
    let mut out = std::io::BufWriter::new(std::io::stdout().lock());
    for i in 0..100000 {
        write!(out, "int f{}(); ", i).unwrap();
    }
    write!(out, "{}", MAIN1).unwrap();
    for i in 0..100000 {
        write!(out, "sum += f{}(); ", i).unwrap();
    }
    write!(out, "{}", MAIN2).unwrap();
}</pre>

<pre class="codeblock rust">// exsrcgen.rs
use std::io::Write;
const MAIN1: &'static str = "
#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;
int (*fs[100000])();
int main() {
    int sum = 0;
    void *handle = dlopen(\"./libtestso.so\", RTLD_LAZY);
";
const MAIN2: &'static str = "
    printf(\"sum = %d\\n\", sum);
    return 0;
}
";
fn main() {
    let mut out = std::io::BufWriter::new(std::io::stdout().lock());
    write!(out, "{}", MAIN1).unwrap();
    for i in 0..100000 {
        write!(out, "fs[{0}] = (int (*)())dlsym(handle, \"f{0}\"); ", i).unwrap();
    }
    for i in 0..100000 {
        write!(out, "sum += (*fs[{}])(); ", i).unwrap();
    }
    write!(out, "{}", MAIN2).unwrap();
}</pre>

<pre class="codeblock make">.PHONY: all
all: libtestso.so imtest extest
libtestso.so: sosrcgen.rs
    rustc sosrcgen.rs
    ./sosrcgen > sosrc.c
    gcc -shared -fPIC -o libtestso.so sosrc.c
imtest: imsrcgen.rs
    rustc imsrcgen.rs
    ./imsrcgen > imsrc.c
    gcc -o imtest imsrc.c libtestso.so -Wl,-rpath,'$$ORIGIN/'
extest: exsrcgen.rs
    rustc exsrcgen.rs
    ./exsrcgen > exsrc.c
    gcc -o extest exsrc.c
clean:
    rm -f \
      libtestso.so sosrc.c sosrcgen \
      imtest imsrc.c imsrcgen \
      extest exsrc.c exsrcgen</pre>

<p>
    雑にtimeコマンドで計測した結果、実行時間は両者とも15ミリ秒程度で、目立った差はなかった。
    <b>どころか、動的リンクの方がファイルサイズが小さく、かつ実行時間が僅差で短かった。</b>
</p>

<p>
    本来ならば、やたら複雑な関数をリンクするならば遅くなるのかとか、ばらばらのタイミングでリンクすると遅くなるのかとか、検証すべきケースは考えられるが、これほど速ければ特に変わりないのではと思える。
</p>

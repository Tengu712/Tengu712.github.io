<!DOCTYPE html>
<html lang='ja'>

<head>
  <CHeader />
  <PostTitle key="bitmap-collision" />
</head>

<CBody>
  <Headline key="bitmap-collision" />

  <hr>

  <h2>概要</h2>

  <CImage src="https://img.skdassoc.work/posts/bitmap-collision/01.gif" caption="矩形の判定でのシミュレーション" width="50%" />

  <p>
    当記事は、<b>2D弾幕STGにおける衝突判定</b>をビットマップ化することで高速化できるか、という実験の報告である。
  </p>

  <p>
    2D弾幕STGに限らず2Dゲーム全般において、余程凝らない限り、レンダリングは16ms以内に完遂される。
    一方で、物体の演算は、それが複雑であったり・総数が多かったりすると、16msに収まらない場合がある。
    こと衝突判定については、愚直に実装すると<IM>O(N^2)</IM>となるため、物体の数が増えるほどコストが無視できない計算となる。
  </p>

  <p>
    しかし、単純な2D弾幕STGは「敵や敵の弾」と「自機や自機の弾」の二種類しか当たり判定を持たない。
    この性質を利用して、ビットマップを用いた実質<IM>O(N)</IM>での衝突判定の性能を検証する。
  </p>

  <div style="text-align: center;">
    <a href="https://github.com/Tengu712/Bitmap-Collision-Experiment">ソースコードはこちら</a>
  </div>

  <h2>ビットマップ方式</h2>

  <p>
    「何かと衝突した」という程度の衝突判定は、自分の当たり判定の座標に「何か」がないかを確認すればいい。
    つまり、座標をkeyに「何かがあること」というvalueを得られればいい。
    これに適したデータ構造は、ビットマップであろう。
  </p>

  <p>
    衝突判定をビットマップを用いて行うのは、タイルベースゲームにおいては珍しいことではない。
    ビットマップのサイズが小さく、「何かがあるか否か」という単純な真理値を持つだけでいいからである。
  </p>

  <p>
    しかし、2D弾幕STGのような連続的な座標を取る物体の衝突判定においては、タイルベースゲーム程簡単ではない。
    一ピクセルに、二次元的な当たり判定の情報を詰めなければならないからである。
    愚直な実装は、ビットを内部ピクセルとする方法であろう。
    しかし、後述するが、これはそれだけ多くのサンプリングを行うことに他ならず、計算量が増えてしまう。
  </p>

  <p>
    ここで、一旦、<b>低精度で衝突判定を行う</b>ことにして、一ピクセルにおける物体の占有率(coverage)を考える。
  </p>

  <p>
    原理的には次の図の通りである。
    自分の当たり判定がある座標のピクセルを参照し、自分の当たり判定のcoverageと相手のビットマップ上のcoverageの合計が閾値を超えているか否かで判定する。
  </p>

  <CImage src="https://img.skdassoc.work/posts/bitmap-collision/02.png" caption="coverageを用いる衝突判定の原理" width="85%" />

  <h2>円の判定</h2>

  <p>
    円は、中心からの距離が一定である図形である。
    こと2D弾幕STGの衝突判定においては、一般的な弾の当たり判定は円であるべきである。
    （東方紅魔郷がすべての当たり判定に矩形を用いているのは、東方界隈では有名）
  </p>

  <p>
    円での衝突判定を行うアルゴリズムは以下のようになる。
  </p>

  <ol>
    <li>
      グループ1のすべての物体について、
      <ol>
        <li>物体の座標を更新</li>
        <li>グループ1のビットマップに物体のcoverageを記録</li>
        <li>物体のビットマップに物体のcoverageを記録</li>
      </ol>
    </li>
    <li>
      グループ2のすべての物体について、
      <ol>
        <li>物体の座標を更新</li>
        <li>グループ2のビットマップに物体のcoverageを記録</li>
        <li>物体のビットマップに物体のcoverageを記録</li>
      </ol>
    </li>
    <li>グループ1のすべての物体について、物体のビットマップとグループ2のビットマップから衝突判定</li>
    <li>グループ2のすべての物体について、物体のビットマップとグループ1のビットマップから衝突判定</li>
  </ol>

  <p>
    coverageの記録に三点の難点がある。
  </p>

  <p>
    まず、物体が存在しうるピクセルのみを更新すればいいが、これを判定するのは難しい。
    従って、
    左を<IM>\lfloor x-r \rfloor</IM>、
    右を<IM>\lceil x+r \rceil</IM>、
    下を<IM>\lfloor y-r \rfloor</IM>、
    上を<IM>\lceil y+r \rceil</IM>
    とする矩形領域内を更新領域とし、
    ピクセルの中点が
    <IM>r+\sqrt{2}</IM>より遠ければcontinue、
    <IM>r-\sqrt{2}</IM>より近ければ最大値とし、
    それ以外は境界上とみなしてサンプリングを行う。
  </p>

  <p>
    また、正方形と円が与えられたとき、共通面積を算出するのは数学的に難しい。
    つまり、coverageを数学的計算によって算出することはできない。
    従って、ピクセルを幾つかに分割してサンプリングを行い、その結果を総合してcoverageを概算する。
  </p>

  <p>
    そして、グループごとのビットマップだけを比較しても、正しい衝突判定はできない。
    なぜなら、ある物体が与えられたとき「coverageが0より大きい→ある物体が重なっている」は真ではないからである。
    従って、物体ごとにビットマップを持つ必要がある。
  </p>

  <p>
    以上を考慮すると、計算量は<IM>O(NSR^2)</IM>であると考えられる。
    ただし、物体数を<IM>N</IM>、物体の半径を<IM>R</IM>、サンプル数を<IM>S</IM>とする。
    <IM>SR^2</IM>が<IM>N</IM>に対して十分小さいとき、計算量は<IM>O(N)</IM>に見積もられる。
  </p>

  <h2>矩形の判定</h2>

  <p>
    前章の判定は、<IM>SR^2</IM>の計算量が地味に無視できないのに加え、ビットマップにアクセスするためのオーバーヘッドのためにか、実はそれほど速度が出ない。
    どれほど速度が出ないかというと、<IM>N=1000</IM>の衝突判定でようやく愚直実装に追いつく程である。
  </p>

  <p>
    そこで、<b>conservativityを完全に無視して当たり判定を矩形にする</b>ことによって、サンプリングおよび物体ごとのビットマップを消すことにする。
  </p>

  <p>
    矩形による判定では境界のcoverageを求めるのが容易である。次のように求める。
  </p>

  <ul>
    <li>左辺：<IM>1-(left-\lfloor left \rfloor)</IM></li>
    <li>右辺：<IM>right-\lfloor right \rfloor</IM></li>
    <li>下辺：<IM>1-(bottom-\lfloor bottom \rfloor)</IM></li>
    <li>上辺：<IM>top-\lfloor top \rfloor</IM></li>
  </ul>

  <p>
    領域の頂点および各辺のcoverageを保存しておけば、coverageが0より大きいピクセルについて、自物体における外か内か境界上かでcoverageを場合分ければいいだけである。
  </p>

  <p>
    計算量は<IM>O(NR^2)</IM>となる。
    こちらも同様に、<IM>R^2</IM>が<IM>N</IM>に対して十分小さいとき、<IM>O(N)</IM>に見積もられる。
    ただし、円の実装が各ピクセルに対して条件分岐していたのに対し、矩形の実装では走査の開始と終了のみ条件分岐を行うため、実際の計算量は円の実装より少なくなる。
  </p>

  <h2>結果</h2>

  <p>
    <IM>N=100, 500, 1000, 2000, 3000, 4000, 5000</IM>とし、それぞれ1000フレーム間物理演算を行った。
    結果を線形補完したグラフを次に示す。
  </p>

  <CImage src="https://img.skdassoc.work/posts/bitmap-collision/03.png" caption="結果(全体)" width="70%" />

  <p>
    確かにビットマップ方式では<IM>O(N)</IM>となっていることがわかる。
    しかし、これでは差が開きすぎていて、交差点が見えづらい。
    従って、X軸の範囲を0から2000、Y軸の範囲を0から2までトリミングしたグラフを次に示す。
  </p>

  <CImage src="https://img.skdassoc.work/posts/bitmap-collision/04.png" caption="結果(部分)" width="70%" />

  <p>
    円の判定は<IM>N=1000</IM>で追いつき、矩形の判定では<IM>N=200</IM>付近で追いついていることがわかる。
  </p>

  <h2>結果を受けて</h2>

  <p>
    ビットマップ方式を使いましょう。……とはならない。
    特に、矩形の判定は、conservativityを完全に無視しているため、プレイ体験を大きく損なう可能性がある。
  </p>

  <p>
    前章のグラフは、1000フレーム間演算を行っていることを考慮すると、単位を秒からミリ秒へ読み換えれば、1フレームにかかる時間がわかる。
    つまり、<IM>N=1000</IM>のとき、愚直実装と円の実装は1ミリ秒である。
    <b>ぶっちゃけ1ミリ秒なんて誤差なので、衝突判定の最適化をする理由は、実はないのかもしれない</b>。
  </p>

  <p>
    このことを踏まえて、どの方式を使うべきか、以下のように考えた。
  </p>

  <ul>
    <li>正確な衝突判定を行いたい→愚直</li>
    <li>物体の数が少ない→愚直</li>
    <li><IM>N&gt;2000</IM>となるような衝突判定を行いたい→円</li>
    <li>とにかく高速に衝突判定をしたい→矩形</li>
    <li>そもそも矩形で衝突判定をする→矩形</li>
  </ul>

  <p>
    ところで、このビットマップ方式における当たり判定の書込みは、レンダリング処理に他ならないため、GPUで行うことで高速化する方法が考えられる。
    興味が湧いたら、実装するかもしれない。
  </p>

  <Tombstone />

  <hr>

  <Deadline key="bitmap-collision" />
</CBody>

</html>
---
layout: ../../layouts/PostLayout.astro
title: "GPUを用いたビットマップによる衝突判定"
genre: "tech"
tags: ["cg", "directx", "experiment"]
date: "2025/03/09"
---
import Image from "../../components/Image.astro";

## 概要

<Image src="https://img.skdassoc.work/posts/bitmap-collision-with-gpu/01.gif" caption="シミュレーションの様子" />

[だいぶ昔に行ったビットマップによる衝突判定実験](https://skdassoc.com/posts/bitmap-collision/)の続きです。
衝突判定用のビットマップをDirect3D12を用いて行った場合、どのくらい速くなるのかをまとめた記事になります。

前提として、この衝突判定は2DSTGに用いることを想定しています。

<div style="text-align: center;">
[ソースコードはこちら](https://github.com/Tengu712/bitmap-collision-with-gpu-experiment)
</div>



## 問題点と対策

早速ですが、GPUを用いたビットマップによる衝突判定には幾つかの問題があります。

まず、RGBAビットマップには多くの情報を記録できません。
この性質のため、次の2点の問題を抱えます。

- 衝突相手のインスタンスを取得できない
- 記録できる物体の種類が限られる (RGBAそれぞれに種類を割り当てる場合4種類)

一点目の問題は大した問題ではありません。
例えば、領域内の敵弾を自ホーミング弾に変えるボムは、ボムの判定に衝突したら自ホーミング弾に変わるという性質を敵弾に備えれば解決します。

二点目の問題も大した問題ではありません。
2DSTGにおいて判定を持つべき物体は、敵・敵弾・自ボム・ボムであり、4種類で足ります。
もし4種類で足りないならば、チャンネル数を上げるなり、ビットで管理するなりすれば解決します。

また、GPUつまりグラフィックスAPIは非同期に描画を行います。
この都合上、GPUが描画を行っている間に次フレームの計算を行います。
そのため、次の問題を抱えます。

- ビットマップには1フレーム前の位置情報が記録される

この問題も大した問題ではありません。
1フレーム前の状態も保存しておき、遡及的に衝突判定を行えば解決します。



## 結果と考察

前回同様、 $100, 500, 1000, 2000, 3000, 4000, 5000$ 個の物体(円)を2種類分作り、それぞれ1000フレーム間物理演算を行った結果を次に示します。

<Image src="https://img.skdassoc.work/posts/bitmap-collision-with-gpu/02.png" caption="結果(全体)" />

随分と高速化されていることが分かります。
物体の数が5000個あるとき、ビットマップを用いない愚直な衝突判定では1フレームあたり25ミリ秒かかっているのに対し、ビットマップを用いた衝突判定では1.4ミリ秒程度です。

2線の交差点付近を拡大した図を次に示します。

<Image src="https://img.skdassoc.work/posts/bitmap-collision-with-gpu/03.png" caption="結果(部分)" />

物体の数が500から750個の間に交差点があります。
このことから、弾が600個程度ある状態でなければ実用的ではないと言うこともできる……というわけではありません。
垂直同期を取るゲームを考えれば、GPUが非同期に描画を行う都合上、ビットマップの描画時間は無視して構いません。
描画時間を無視した図を次に示します。

<Image src="https://img.skdassoc.work/posts/bitmap-collision-with-gpu/04.png" caption="描画時間を除いた結果(部分)" />

このことから、弾の数が少なくとも十分有用であることがわかります。

また、描画時間を無視しても良いということは、逆に言えば、衝突判定のアルゴリズムの良し悪しでパフォーマンスが決まるとも言えます。
物体の座標のみビットマップを参照すれば、 $O(1)$ で衝突判定が行えます。
例えば、自機と敵弾、敵とレーザー、弾消しボムと弾などはこのアルゴリズムを使えます。

ところで、前回の実験の円形判定の結果と比較すると、今回の結果は随分と良く出ています。
実は、これにはトリックがあります。
今回は円周上のピクセルのみビットマップを参照しています。
前回は円上のすべてのピクセルについてビットマップを参照していたため、パフォーマンスが悪く出ていました。
しかし、これは同じ大きさの物体しかなく・離れた場所に生成されることを良いことに実現しているのであり、例えば大きな円で同じことを行うと円の中の物体に対して衝突判定が下されないことになります。

以上を踏まえて、とはいえ、衝突判定を表示できるというメリットもありますし、個人的には2DSTGを作るときは必須のテクニックかなと思います。


## 雑記

- std::powf()が遅過ぎてビビった。
- std::vector(100)ってreserveではなくてfillなんですねぇ。
- PIXがなければもう少し実装時間がかかっていたことだろう。感謝。
- ブレゼンハムのアルゴリズム。ぶれぜんはむのあるごりずむ。
